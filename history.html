<!DOCTYPE html>
<meta charset=utf-8>
<title>History API - Dive Into HTML5</title>
<!--[if lt IE 9]><script src=j/html5.js></script><![endif]-->
<link rel=alternate type=application/atom+xml href=https://github.com/diveintomark/diveintohtml5/commits/master.atom>
<link rel=stylesheet href=screen.css>
<style>
body{counter-reset:h1 11}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#history>Dive Into <abbr>HTML5</abbr></a> <span class=u>&#8227;</span>
<h1><br>Manipulando Histórico <br>Para Diversão & Lucro</h1>
<p id=toc>&nbsp;
<p class=a>&#x2767;
<h2 id=divingin>Mergulhando</h2>

<p class=f><img src=i/aoc-a.png alt=T width=107 height=105> barra de endereços do navegador é talvez a peça mais antiga da interface de usuário no mundo. Há <abbr>URLs<abbr> em outdoors, nas laterais de trens, e até mesmo em grafites de rua. Combinado com o botão de voltar &mdash; provavelmente o botão mais importante do navegador &mdash; você tem uma maneira poderosa para avançar e voltar no vasto conjunto de recursos interligados chamado de Web.

<p>A <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html><abbr>API</abbr> de histórico da <abbr>HTML5</abbr></a> é uma maneira padronizada para manipular o histórico do navegador via script. Parte desta <abbr>API</abbr> &mdash; navegando pelo histórico &mdash; está disponível em versões anteriores do <abbr>HTML</abbr>. As novas funcionalidades em <abbr>HTML5</abbr> incluem uma maneira de adicionar entradas ao histórico do navegador, para visivelmente alterar a <abbr>URL</abbr> na barra de endereços do navegador (sem precisar atualizar a página), e um evento é acionado quando estas entradas são removidas da pilha do navegador quando o usuário pressiona o botão voltar. Isto quer dizer que a <abbr>URL</abbr> na barra de endereços do navegador pode continuar seu trabalho de ser um identificador único para o recurso atual, mesmo em aplicações com scripts pesados que nem sempre necessitam de uma atualização na página toda.

<p class=a>&#x2767;

<h2 id=why>O por que</h2>

<p class=ss style="float:left;margin:0 1.75em 1.75em 0;width:218px"><img src=i/openclipart.org_johnny_automatic_demon_reading_Stewart_Orr.png alt="demon reading book" width=218 height=231>

<p>Por que você iria manipular manualmente a barra de endereços do navegador? Afinal, um simples link pode navegar até uma nova <abbr>URL</abbr>; essa é a forma que a web tem funcionado nos ultimos 20 anos. E isso vai continuar funcionando desta forma. Esta <abbr>API</abbr> não tenta revolucionar a web. Muito pelo contrario. Nos últimos anos, os desenvolvedores web têm encontrado novas e excitantes formas de revolucionar a web sem a ajuda de padrões emergentes. A <abbr>API</abbr> de histórico da <abbr>HTML5</abbr> foi na verdade criada para garantir que as <abbr>URL</abbr>s continuem sendo uteis em aplicações web com scrpts pesados.

<p>Voltando aos princípios, o que uma <abbr>URL</abbr> faz? Ela identifica um recurso único. Você pode fazer um link direto para ela; você pode marca-la; motores de busca podem indexa-la; você pode copia-la e cola-la e envia-la por e-mail para outra pessoa, esta pessoa pode clicar e acabara vendo o mesmo recurso que você viu originalmente. Estas são todas qualidades excelentes.  <abbr>URL</abbr>s são importantes.

<p>Então nos queremos que recursos únicos tenham <abbr>URL</abbr>s únicas. Mas ao mesmo tempo, navegadores sempre tiveram uma limitação fundamental: Se você mudar a <abbr>URL</abbr>, mesmo através de script, ele dispara uma requisição ao servidor web remoto e recarrega toda a página. Isso consome tempo e recursos, e parece um desperdício quando você esta navegando para uma página que é substancialmente semelhante à sua página atual. Tudo que possui na nova pagina é baixado, até mesmo as partes que são exatamente as mesmas da página atual. Não tem como alterar a <abbr>URL</abbr> em um navegador, mas este fazer download de apenas metade da página.

<p>A <abbr>API</abbr> de histórico do <abbr>HTML5</abbr> permite que você faça isso. Ao invés de desencadear uma atualização na página inteira, você pode utilizar o script para, em essência, baixar metade de uma página. Esta ilusão é um truque difícil, e requer algum trabalho da sua parte. Você esta prestando atenção?

<p class=ss><img src=i/openclipart.org_johnny_automatic_card_trick.png width=287 height=238 alt="Magico fazendo um truque de cartas" />

<p id=illusion>Digamos que você possui duas páginas, página A e página B. As duas páginas são 90% identicas; somente 10% do conteudo destas páginas é diferente. O usuario navega para a págna A, então tenta navegar para a página B. Mas ao invés de desencadear uma atualização na página toda, você interrompe o navegador e segue estes passos manualmente:

<ol>
<li><em>Carrega os 10% da página</em> através da página B que é diferente da página A (provavelmente utilizando <code>XMLHttpRequest</code>). Isso vai exigir algumas modificações no lado servidor de sua aplicação web. Você vai precisar escrever um código que retorne apenas os 10% da página B que é diferente da página A. Isso pode ser uma <abbr>URL</abbr> oculta ou um parâmetro de consulta que o usuário final normalmente não vê.
<li><em>Troque o conteúdo alterado</em> (utilizando <code>innerHTML</code> ou outro método <abbr>DOM</abbr>). Talvez você precise redefinir os manipuladores de eventos que foram alterados junto com o conteúdo.
<li><em>Atualize a barra de endereços do navegador</em> com a <abbr>URL</abbr> da página B, utilizando um método particular da <abbr>API</abbr> de histórico do <abbr>HTML5</abbr> que eu já vou mostrar para você.
</ol>

<p>Ao final desta ilusão (se você a executar corretamente), o navegador acaba com um <abbr>DOM</abbr> que é idêntico a página B, como se você tivesse navegado diretamente para a página B. A barra de endereços do navegador acaba ficando com uma <abbr>URL</abbr> que é idêntica a da página B, como se você tivesse navegado diretamente para a página B. Mas na verdade você nunca navegou até a página B, e você nunca precisou atualizar toda a página. Esta é a ilusão. Mas porque a página "compilada" se parece exatamente como a página B e possui a mesma <abbr>URL</abbr>, o usuário provavelmente nunca notara a diferença (nem te agradecera por todo trabalho pesado micro gerenciando suas experiências).

<p class=a>&#x2767;

<h2 id=how>O Como</h2>

<p>A <abbr>API</abbr> de histórico do <abbr>HTML5</abbr> é apenas vários métodos no objeto <code>window.history</code>, mais um evento no objeto <code>window</code>. Você pode utilizar isto para <a href=detect.html#history>detectar o suporte da<abbr>API</abbr> de histórico</a>. O suporte atualmente é limitado para as ultimas versões de alguns navegadores, colocando essa técnica diretamente no campo "Melhoria em progresso".

<table class=bc>
<caption>Suporte para history.pushState</caption>
<thead>
<tr><th title="Internet Explorer">IE<th title="Mozilla Firefox">Firefox<th title="Apple Safari">Safari<th title="Google Chrome">Chrome<th>Opera<th>iPhone<th>Android
<tbody>
<tr><td>&middot;<td>4.0+<td>5.0+<td>8.0+<td>11.50+<td>4.2.1+<td>&middot;
</table>

<p><a href=examples/history/fer.html>dive into dogs</a> é um exemplo simples, mas não trivial de usar a <abbr>API</abbr> de histórico do <abbr>HTML5</abbr>. Ele demonstra um padrão comum: um longo artigo com uma galeria de fotos. Em um navegador compatível, navegando pelos links "Próximo" e "Anterior" na galeria de fotos irá atualizar apenas foto no lugar <em>e atualizará o <abbr>URL</abbr> na barra de endereços do navegador</em>, sem desencadear uma atualização na página inteira. Em navegadores sem suporte - ou, de fato, navegadores compatíveis onde o usuário tenha desabilitado scripts - os links simplesmente funcionam como links normais, levando você a uma nova página com uma atualização na página toda.

<p>Isso nos leva a um ponto importante:

<div class=pf>
<h4>Professor Markup diz</h4>
<div class=inner>
<blockquote><p>Se sua aplicação web falhar em navegadores com script desabilitado, O cachorro de Jakob Nielsen vai até a sua casa e defecara no seu carpete.
</blockquote>
</div>
</div>

<p id=gallery-markup>Vamos dar uma olhada no exemplo <a href=examples/history/fer.html>dive into dogs</a> e ver como ele funciona. Esta é a marcação relevante para uma única foto:

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> O penhor
<pre><code>&lt;aside id="gallery">
  &lt;p class="photonav">
    &lt;a id="photonext" href="casey.html">Next &amp;gt;&lt;/a>
    &lt;a id="photoprev" href="adagio.html">&amp;lt; Previous&lt;/a>
  &lt;/p>
  &lt;figure id="photo">
    &lt;img id="photoimg" src="gallery/1972-fer-500.jpg"
            alt="Fer" width="500" height="375">
    &lt;figcaption>Fer, 1972&lt;/figcaption>
  &lt;/figure>
&lt;/aside></code></pre>

<p>Nada diferente aqui. A foto em si é uma <code>&lt;img></code> dentro de uma <code>&lt;figure></code>, o link é um elemento <code>&lt;a></code> normal, e a coisa toda esta colocada dentro de um <code>&lt;aside></code>. É importante que estes links regulares realmente funcionem. Todo o código se passa atrás de um <a href=detect.html#history>script de detecção</a>. Se um usuário estiver utilizando um navegador sem suporte, nada do nosso código chique da <abbr>API</abbr> de histórico será executado. E, claro, sempre há alguns usuários com o script desativado por completo.

<p>The main driver function gets each of these links and passes it to a function, <code>addClicker()</code>, which does the actual work of setting up the custom <code>click</code> handler.

<pre><code>function setupHistoryClicks() {
  addClicker(document.getElementById("photonext"));
  addClicker(document.getElementById("photoprev"));
}</code></pre>

<p>This is the <code>addClicker()</code> function. It takes an <code>&lt;a></code> element and adds a <code>click</code> handler. And within this <code>click</code> handler is where it gets interesting.

<pre style="float:left"><code>function addClicker(link) {
  link.addEventListener("click", function(e) {
    swapPhoto(link.href);
    history.pushState(null, null, link.href);
    e.preventDefault();
  }, false);
}</code></pre>
<p class="legend right" style="margin-top:5em"><span class=arrow>&nbsp;&#x219c;</span> Interesting

<p style="clear:left">The <code>swapPhoto()</code> function performs the first two steps of our <a href=#illusion>three-step illusion</a>. The first half of the <code>swapPhoto()</code> function takes part of the <abbr>URL</abbr> of the navigation link itself &mdash; <code>casey.html</code>, <code>adagio.html</code>, <i>&amp;</i>c. &mdash; and constructs a <abbr>URL</abbr> to a hidden page that contains nothing but the markup required by the next photo.

<pre><code>function swapPhoto(href) {
  var req = new XMLHttpRequest();
  req.open("GET",
           "http://diveintohtml5.org/examples/history/gallery/" +
             href.split("/").pop(),
           false);
  req.send(null);</code></pre>

<p>Here is a sample of the markup returned by <code><a href=http://diveintohtml5.org/examples/history/gallery/casey.html>http://diveintohtml5.org/examples/history/gallery/casey.html</a></code>. (You can verify this in your browser by visiting that <abbr>URL</abbr> directly.)

<pre><code>&lt;p class="photonav">
  &lt;a id="photonext" href="brandy.html">Next &amp;gt;&lt;/a>
  &lt;a id="photoprev" href="fer.html">&amp;lt; Previous&lt;/a>
&lt;/p>
&lt;figure id="photo">
  &lt;img id="photoimg" src="gallery/1984-casey-500.jpg"
          alt="Casey" width="500" height="375">
  &lt;figcaption>Casey, 1984&lt;/figcaption>
&lt;/figure></code></pre>

<p>Does that look familiar? It should. It&#8217;s the <a href=#gallery-markup>same basic markup that the original page used</a> to display the first photo.

<p>The second half of the <code>swapPhoto()</code> function performs the second step of our <a href=#illusion>three-step illusion</a>: inserting this newly downloaded markup into the current page. Remember that there is an <code>&lt;aside></code> wrapping the entire figure, photo, and caption. So inserting the new photo markup is a one-liner, setting the <code>innerHTML</code> property of the <code>&lt;aside></code> to the <code>responseText</code> property returned from <code>XMLHttpRequest</code>.

<pre><code>  if (req.status == 200) {
    document.getElementById("gallery").innerHTML = req.responseText;
    setupHistoryClicks();
    return true;
  }
  return false;
}</code></pre>

<p>(Also notice the call to <code>setupHistoryClicks()</code>. This is necessary to reset the custom <code>click</code> event handlers on the newly inserted navigation links. Setting <code>innerHTML</code> wipes out any trace of the old links and their event handlers.)

<p>Now, let&#8217;s go back to the <code>addClicker()</code> function. After successfully swapping out the photo, there&#8217;s one more step in our <a href=#illusion>three-step illusion</a>: setting the <abbr>URL</abbr> in the browser location bar without refreshing the page.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> The turn
<pre><code>history.pushState(null, null, link.href);</code></pre>

<p>The <code>history.pushState()</code> function takes three parameters:

<ol>
<li><code>state</code> can be any <abbr>JSON</abbr> data structure. It is passed back to the <code>popstate</code> event hander, which you&#8217;ll learn about in just a moment. We don&#8217;t need to track any state in this demo, so I&#8217;ve left it as <code>null</code>.
<li><code>title</code> can be any string. This parameter is currently unused by major browsers. If you want to set the page title, you should store it in the <code>state</code> argument and set it manually in your <code>popstate</code> callback.
<li><code>url</code> can be, well, any <abbr>URL</abbr>. This is the <abbr>URL</abbr> you want to appear in the browser&#8217;s location bar.
</ol>

<p>Calling <code>history.pushState</code> will immediately change the <abbr>URL</abbr> in the browser&#8217;s location bar. So is that the end of the illusion? Well, not quite. We still need to talk about what happens when the user presses the all-important back button.

<p>Normally when the user navigates to a new page (with a full page refresh), the browser pushes the new <abbr>URL</abbr> onto its history stack and downloads and draws the new page. When the user presses the back button, the browser pops one page off its history stack and redraws the previous page. But what happens now that you&#8217;ve short-circuited this navigation to avoid a full page refresh? Well, you&#8217;ve faked &#8220;moving forward&#8221; to a new <abbr>URL</abbr>, so now you also need to fake &#8220;moving backward&#8221; to the previous <abbr>URL</abbr>. And the key to faking &#8220;moving backwards&#8221; is the <code>popstate</code> event.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> The prestige
<pre><code>window.addEventListener("popstate", function(e) {
    swapPhoto(location.pathname);
}</code></pre>

<p>After you&#8217;ve used the <code>history.pushState()</code> function to push a fake <abbr>URL</abbr> onto the browser&#8217;s history stack, when the user presses the back button, the browser will fire a <code>popstate</code> event on the <code>window</code> object. This is your chance to complete the illusion once and for all. Because making something disappear isn't enough; you have to bring it back.

<p>In this demonstration, &#8220;bringing it back&#8221; is as simple as swapping in the original photo, which we do by calling the <code>swapPhoto()</code> with the current location. By the time your <code>popstate</code> callback is called, the <abbr>URL</abbr> visible in the browser&#8217;s location bar has been changed to the previous <abbr>URL</abbr>. Also, the global <code>location</code> property has already been updated with the previous <abbr>URL</abbr>.

<p>To help you visualize this, let&#8217;s step through the entire illusion from the beginning to the end:

<ul>
<li>User loads <code><a href=http://diveintohtml5.org/examples/history/fer.html>http://diveintohtml5.org/examples/history/fer.html</a></code>, sees story and a photo of Fer.
<li>User clicks the link labeled &#8220;Next,&#8221; an <code>&lt;a></code> element whose <code>href</code> property is <code><a href=http://diveintohtml5.org/examples/history/casey.html>http://diveintohtml5.org/examples/history/casey.html</a></code>.
<li>Instead of navigating <code><a href=http://diveintohtml5.org/examples/history/casey.html>http://diveintohtml5.org/examples/history/casey.html</a></code> with a full page refresh, the custom <code>click</code> handler on the <code>&lt;a></code> element traps the click and executes its own code.
<li>Our custom <code>click</code> handler calls the <code>swapPhoto()</code> function, which creates an <code>XMLHttpRequest</code> object to synchronously download the <abbr>HTML</abbr> snippet located at <code><a href=http://diveintohtml5.org/examples/history/gallery/casey.html>http://diveintohtml5.org/examples/history/<strong>gallery</strong>/casey.html</a></code>.
<li>The <code>swapPhoto()</code> function sets the <code>innerHTML</code> property of the photo gallery wrapper (an <code>&lt;aside></code> element), thereby replacing the captioned photo of Fer with a captioned photo of Casey.
<li>Finally, our custom <code>click</code> handler calls the <code>history.pushState()</code> function to manually change the <abbr>URL</abbr> in the browser&#8217;s location bar to <code><a href=http://diveintohtml5.org/examples/history/casey.html>http://diveintohtml5.org/examples/history/casey.html</a></code>.
<li>User clicks the browser&#8217;s back button.
<li>The browser notices that a <abbr>URL</abbr> has been manually pushed onto the history stack (by the <code>history.pushState()</code> function). Instead of navigating to the previous <abbr>URL</abbr> and redrawing the entire page, the browser simply updates the location bar to the previous <abbr>URL</abbr> (<code><a href=http://diveintohtml5.org/examples/history/fer.html>http://diveintohtml5.org/examples/history/fer.html</a></code>) and fires a <code>popstate</code> event.
<li>Our custom <code>popstate</code> handler calls the <code>swapPhoto()</code> function again, this time with the previous <abbr>URL</abbr> that by now is already visible in the browser&#8217;s location bar.
<li>Again using <code>XMLHttpRequest</code>, the <code>swapPhoto()</code> function downloads a snippet of <abbr>HTML</abbr> located at <code><a href=http://diveintohtml5.org/examples/history/gallery/fer.html>http://diveintohtml5.org/examples/history/<strong>gallery</strong>/fer.html</a></code> and sets the <code>innerHTML</code> property of the <code>&lt;aside></code> wrapper element, thereby replacing the captioned photo of Casey with a captioned photo of Fer.
</ul>

<p>The illusion is complete. All visible evidence (the content of the page, and the <abbr>URL</abbr> in the location bar) suggests to the user that they have navigated forward one page and backward one page. But no full page refresh ever occurred &mdash; it was all a meticulously executed illusion.

<p class=a>&#x2767;

<h2 id=further-reading>Further Reading</h2>

<ul>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html>Session history and navigation</a> in the <abbr>HTML5</abbr> draft standard
<li><a href=https://developer.mozilla.org/en/DOM/Manipulating_the_browser_history>Manipulating the browser history</a> on Mozilla Developer Center
<li><a href=http://html5demos.com/history>Simple history <abbr>API</abbr> demo</a>
<li><a href=http://www.20thingsilearned.com/>20 Things I Learned About Browsers and the Web</a>, an advanced demo that uses the history <abbr>API</abbr> and other <abbr>HTML5</abbr> techniques
<li><a href="http://www.facebook.com/note.php?note_id=438532093919">Using <abbr>HTML5</abbr> today</a> describes <a href=http://www.facebook.com/>Facebook&#8217;s</a> use of the history <abbr>API</abbr>
<li><a href=https://github.com/blog/760-the-tree-slider>The Tree Slider</a> describes <a href=https://github.com/>Github&#8217;s</a> use of the history <abbr>API</abbr>
<li><a href=https://github.com/balupton/History.js/>History.js</a>, a meta-<abbr>API</abbr> for manipulating history in both newer and older browsers
</ul>

<p class=a>&#x2767;
<p>Este foi &#8220;Manipulando Histórico Para Diversão & Lucro&#8221; O <a href=table-of-contents.html>Índice Analítico</a> tem muito mais, se você quiser continuar a leitura.

<div class=pf>
<h4>Você sabia?</h4>
<div class=moneybags>
	<blockquote><p>Em associação a Google Press, O&#8217;Reilly está distruindo este livro em variados formatos, incluindo papel, ePub, Mobi, <abbr>DRM</abbr>-free e <abbr>PDF</abbr>. A edição paga é chamada &#8220;HTML5: Up &amp; Running,&#8221; e está disponível agora.
	<p>Se você gostou dessa introdução e quer mostrar como apreciou, basta <a href="http://www.amazon.com/HTML5-Up-Running-Mark-Pilgrim/dp/0596806027?ie=UTF8&amp;tag=diveintomark-20&amp;creativeASIN=0596806027">comprar o livro &#8220;HTML5: Up &amp; Running&#8221; com esse link afiliado</a> ou <a href=http://oreilly.com/catalog/9780596806033>comprar a edição eletrônica diretamente da O&#8217;Reilly</a>. Você vai ganhar um livro, e eu vou ganhar um trocado. Atualmente não aceito doações diretas.
	</blockquote>
</div>
</div>

<p class=c>Copyright MMIX&ndash;MMXI <a href=about.html>Mark Pilgrim</a>

<form action=http://www.google.com/cse><div><input type=hidden name=cx value=017884302975346027366:bgclqh8nvse><input type=hidden name=ie value=UTF-8><input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<script src=j/jquery.js></script>
<script src=j/modernizr.js></script>
<script src=j/dih5.js></script>
